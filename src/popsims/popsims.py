
from scipy.interpolate import griddata
import astropy.units as u
import numba
import pandas as pd
import numpy as np
import os
import sys

from .relations import  scale_to_local_lf, teff_to_spt_kirkpatrick, \
spt_to_teff_kirkpatrick, teff_to_spt_pecaut, spt_to_teff_pecaut
from .core_tools import sample_from_powerlaw

#DATA_FOLDER=os.environ['POPSIMS_DATA_FOLDER']

#CODE_FOLDER=os.path.abspath(os.path.join(os.path.dirname(__file__),os.pardir))
#sys.path.append(CODE_FOLDER)
#DATA_FOLDER= CODE_FOLDER+'/data/'

def _read_bintemplates():
    from .binaries import BINARIES 
    #must be a pickle file with columns prim, sec, sys all floats
    tbl=pd.DataFrame(BINARIES)
    return [tbl.prim.values, tbl.sec.values, tbl.sys.values]


def get_system_type(pr, sc):
    """
    Determine the type of a system based on its primary and secondary attributes.

    This function takes the primary and secondary attributes of a system and
    uses interpolation to determine the type of the system based on these
    attributes. The system type is returned as a floating point value.

    Args:
        pr: The primary attribute of the system, as a floating point value.
        sc: The secondary attribute of the system, as a floating point value.

    Returns:
        The type of the system, as a floating point value.

    #generated by chatGPT
    """
    # Function implementation goes here

    interpolators= _read_bintemplates()
    #where secondary are nans set to primaries
    sc[np.isnan(sc)]=pr[np.isnan(sc)]
    #interpolate
    interpoints=np.array([interpolators[0], interpolators[1] ]).T
    comb=griddata(interpoints, interpolators[-1] , (pr, sc), method='linear')
    #rember to assign <15 =primary and > 39= primary
    return comb

def evolutionary_model_interpolator(mass, age, model, subset=None):
    """
    Interpolate evolutionary model data to determine the temperature and luminosity of a star.

    This function takes the mass, age, and model type of a star, and uses interpolation to determine the
    temperature and luminosity of the star based on these values. The function can also take an optional
    subset parameter, which can be used to specify a subset of the evolutionary model data to use for the
    interpolation.

    Args:
        mass: The mass of the star, as a floating point value in solar masses.
        age: The age of the star, as a floating point value in years.
        model: The type of evolutionary model to use for the interpolation, as a string.
        subset: An optional subset of the evolutionary model data to use for the interpolation, as a tuple of
            (column name, value) pairs.

    Returns:
        A dictionary containing the mass, age, temperature, and luminosity of the star, as floating point values
        in the appropriate units.
    #generated by chatGPT
    """
    # Function implementation goes here
    from .evol_models import EVOL_MODELS
    evolutiomodel=pd.DataFrame(EVOL_MODELS[model])

    #use the full cloud treatment for saumon models
    if subset != None:
         evolutiomodel=(evolutiomodel[evolutiomodel[subset[0]]==subset[1]]).reset_index(drop=True)
 
    #make age, teff, mass logarithm scale
    valuest=np.log10(evolutiomodel.temperature.values)
    #valueslogg=evolutiomodel.gravity.values
    valueslumn=evolutiomodel.luminosity.values

    valuesm=np.log10(evolutiomodel.mass.values)
    valuesag=np.log10(evolutiomodel.age.values)

    evolpoints=np.array([valuesm, valuesag ]).T

    teffs=griddata(evolpoints, valuest , (np.log10(mass), np.log10(age)), method='linear')
    lumn=griddata(evolpoints, valueslumn , (np.log10(mass), np.log10(age)), method='linear')

    return {'mass': mass*u.Msun, 'age': age*u.Gyr, 'temperature': 10**teffs*u.Kelvin, 
    'luminosity': lumn*u.Lsun}